# we will either split or compute gamma
if (length(S_m[[1]]) >= 2 * l) {
if (nrow(results == 13)) browser()
R_i <- R_i + 2
new_split <- grow_node(X=X, y=y, l=l,
S_m = S_m, R_i = R_i)
if(is.null(new_split)){ #this is added in case S_m[[1]]) >= 2 * l
# but the grow_node (tree split() cannot make any split of the observations
# such that both regions > l. Then we treat it as a leaf)
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
R_i <- R_i - 2
}
else{
results <- rbind(results,new_split[[1]])
S_m <- c(S_m, list(S_m[[1]][new_split[[2]]], S_m[[1]][new_split[[3]]]))
}
# Add R1 and R2 to S_m
#the long indexes is to make sure we index on the correct value for the whole
#data X, not the ones used for the current split only
S_m <- S_m[-1]
} else {
# Compute gamma for leaf node
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
S_m <- S_m[-1]
}
}
rownames(results) <- 1:nrow(results)
return(results)
}
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
results
if (nrow(results) ==13) browser()
grow_tree <- function(X, y, l) {
assertions(X = X, y = y, l = l)
# Initialize the tree with the first split
init <- tree_split(X, y, l)
# Initialize S_m to store the set of observation indices
S_m <- list(init$R1, init$R2)
R_i <- 2
# Initialize results data frame
results <- data.frame(j = init$j, s = init$s,
R1_i = R_i, R2_i = R_i+1, gamma = NA)
# Main loop to grow the tree
while (length(S_m) > 0) {
# As long as not all parts of the tree have been handled,
# we will either split or compute gamma
if (length(S_m[[1]]) >= 2 * l) {
if (nrow(results) ==13) browser()
R_i <- R_i + 2
new_split <- grow_node(X=X, y=y, l=l,
S_m = S_m, R_i = R_i)
if(is.null(new_split)){ #this is added in case S_m[[1]]) >= 2 * l
# but the grow_node (tree split() cannot make any split of the observations
# such that both regions > l. Then we treat it as a leaf)
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
R_i <- R_i - 2
}
else{
results <- rbind(results,new_split[[1]])
S_m <- c(S_m, list(S_m[[1]][new_split[[2]]], S_m[[1]][new_split[[3]]]))
}
# Add R1 and R2 to S_m
#the long indexes is to make sure we index on the correct value for the whole
#data X, not the ones used for the current split only
S_m <- S_m[-1]
} else {
# Compute gamma for leaf node
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
S_m <- S_m[-1]
}
}
rownames(results) <- 1:nrow(results)
return(results)
}
grow_tree(X= X_check, y=y_check, l = 5)
grow_tree(X= X_train, y=y_train, l = 5)
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
X
y
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
debugonce(grow_node)
R_i
new_split
#' function to grow the tree nodes , for the first if statement in grow_tree
grow_node <- function(X, y, l, S_m, R_i ){
new_split <- tree_split(X[S_m[[1]], ], y[S_m[[1]]], l)
if(new_split == NULL) return(NULL)
new_results <- data.frame(
j = new_split$j,
s = new_split$s,
R1_i = R_i,
R2_i = R_i+1,
gamma = NA
)
return(list(new_results, new_split$R1, new_split$R2))
}
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
#' function to grow the tree nodes , for the first if statement in grow_tree
grow_node <- function(X, y, l, S_m, R_i ){
new_split <- tree_split(X[S_m[[1]], ], y[S_m[[1]]], l)
if(new_split == NULL){
return(NULL)
}
new_results <- data.frame(
j = new_split$j,
s = new_split$s,
R1_i = R_i,
R2_i = R_i+1,
gamma = NA
)
return(list(new_results, new_split$R1, new_split$R2))
}
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
#' function to grow the tree nodes , for the first if statement in grow_tree
grow_node <- function(X, y, l, S_m, R_i ){
new_split <- tree_split(X[S_m[[1]], ], y[S_m[[1]]], l)
if(is.null(new_split)){
return(NULL)
}
new_results <- data.frame(
j = new_split$j,
s = new_split$s,
R1_i = R_i,
R2_i = R_i+1,
gamma = NA
)
return(list(new_results, new_split$R1, new_split$R2))
}
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
results
test_set <- bootstrap_func(X=X_train, y=y_train, B=1)
bootstrap_set <- test_set[[1]]
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
test_set <- bootstrap_func(X=X_train, y=y_train, B=1)
bootstrap_set <- test_set[[1]]
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
test_set <- bootstrap_func(X=X_train, y=y_train, B=1)
bootstrap_set <- test_set[[1]]
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
test_set <- bootstrap_func(X=X_train, y=y_train, B=1)
bootstrap_set <- test_set[[1]]
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
test_set <- bootstrap_func(X=X_train, y=y_train, B=1)
bootstrap_set <- test_set[[1]]
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
test_set <- bootstrap_func(X=X_train, y=y_train, B=1)
bootstrap_set <- test_set[[1]]
grow_tree(as.matrix(bootstrap_set[,-1]), bootstrap_set$y, l=20)
function(X, y, l) {
assertions(X = X, y = y, l = l)
# Initialize the tree with the first split
init <- tree_split(X, y, l)
# Initialize S_m to store the set of observation indices
S_m <- list(init$R1, init$R2)
R_i <- 2
# Initialize results data frame
results <- data.frame(j = init$j, s = init$s,
R1_i = R_i, R2_i = R_i+1, gamma = NA)
# Main loop to grow the tree
while (length(S_m) > 0) {
# As long as not all parts of the tree have been handled,
# we will either split or compute gamma
if (length(S_m[[1]]) >= 2 * l) {
if (nrow(results) ==13) browser()
R_i <- R_i + 2
new_split <- grow_node(X=X, y=y, l=l,
S_m = S_m, R_i = R_i)
if(is.null(new_split)){ #this is added in case S_m[[1]]) >= 2 * l
# but the grow_node (tree split() cannot make any split of the observations
# such that both regions > l. Then we treat it as a leaf)
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
R_i <- R_i - 2
}
else{
results <- rbind(results,new_split[[1]])
S_m <- c(S_m, list(S_m[[1]][new_split[[2]]], S_m[[1]][new_split[[3]]]))
}
# Add R1 and R2 to S_m
#the long indexes is to make sure we index on the correct value for the whole
#data X, not the ones used for the current split only
S_m <- S_m[-1]
} else {
# Compute gamma for leaf node
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
S_m <- S_m[-1]
}
}
rownames(results) <- 1:nrow(results)
return(results)
}
tree_split(X_check, y_check, l = 5)
tree_split(X_check, y_check, l = 1)
first_train_split <-tree_split(X_train, y_train, l = 5)
first_train_split
first_train_split$j
first_train_split$s
first_train_split$SS
test_set <- bootstrap_func(X=X_train, y=y_train, B=5)
lapply(test_set, FUN = grow_tree, y=y_train, l = 5 )
train_bagged_trees(X=X_check, y=y_check, B= 20)
train_bagged_trees(X=X_check, y=y_check, B= 20, l = 5)
res <- train_bagged_trees(X=X_check, y=y_check, B= 20, l = 5)
res <- train_bagged_trees(X=X_check, y=y_check, B= 100, l = 5)
res <- train_bagged_trees(X=X_train, y=y_train, B= 100, l = 5)
grow_tree <- function(X, y, l) {
assertions(X = X, y = y, l = l)
# Initialize the tree with the first split
init <- tree_split(X, y, l)
# Initialize S_m to store the set of observation indices
S_m <- list(init$R1, init$R2)
R_i <- 2
# Initialize results data frame
results <- data.frame(j = init$j, s = init$s,
R1_i = R_i, R2_i = R_i+1, gamma = NA)
# Main loop to grow the tree
while (length(S_m) > 0) {
# As long as not all parts of the tree have been handled,
# we will either split or compute gamma
if (length(S_m[[1]]) >= 2 * l) {
R_i <- R_i + 2
new_split <- grow_node(X=X, y=y, l=l,
S_m = S_m, R_i = R_i)
if(is.null(new_split)){ #this is added in case S_m[[1]]) >= 2 * l
# but the grow_node (tree split() cannot make any split of the observations
# such that both regions > l. Then we treat it as a leaf)
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
R_i <- R_i - 2
}
else{
results <- rbind(results,new_split[[1]])
S_m <- c(S_m, list(S_m[[1]][new_split[[2]]], S_m[[1]][new_split[[3]]]))
}
# Add R1 and R2 to S_m
#the long indexes is to make sure we index on the correct value for the whole
#data X, not the ones used for the current split only
S_m <- S_m[-1]
} else {
# Compute gamma for leaf node
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
S_m <- S_m[-1]
}
}
rownames(results) <- 1:nrow(results)
return(results)
}
res <- train_bagged_trees(X=X_check, y=y_check B= 100, l = 1)
res <- train_bagged_trees(X=X_check, y=y_check ,B= 100, l = 1)
res
res <- train_bagged_trees(X=X_train, y=y_train ,B= 100, l = 5)
res
y_train
res <- train_bagged_trees(X=X_train, y=y_train ,B= 1000, l = 5)
res
library(parallel)
# Chunk 3
library(uuml)
library(tidyverse)
data("Hitters")
# Chunk 4
# Remove NA values
Hitters <- Hitters[complete.cases(Hitters),]
# Create test and training set
X_test <- as.matrix(Hitters[1:30, c("Years", "Hits")])
y_test <- Hitters[1:30, c("Salary")]
X_train <- as.matrix(Hitters[31:nrow(Hitters), c("Years", "Hits")])
y_train <- Hitters[31:nrow(Hitters), c("Salary")]
# Chunk 5
SS_func <- function(y_vec, y_bar){
Sum_square <- sum((y_vec - y_bar)^2)
return(Sum_square)
}
assertions <- function(X,y,l){
checkmate::assert_matrix(X)
checkmate::assert_numeric(y, len = nrow(X))
checkmate::assert_int(l)
}
#' function to split observations
#' @param X Design Matrix
#' @param y variable
#' @param l leaf size. Minimum 1
#'
tree_split <- function(X, y, l){
assertions(X=X,y=y,l=l)
SS <<- matrix(Inf, nrow = nrow(X), ncol = ncol(X))
for (j in 1:ncol(X)) {
for (k in 1:nrow(X)) {
s <- X[k, j]  # Split point
R1 <- which(X[, j] <= s)
R2 <- which(X[, j] > s)
# Handle if R1 or R2 is smaller than the leaf size l
if (length(R1) < l || length(R2) < l) next
c1 <- mean(y[R1])
# Compute c2
c2 <- mean(y[R2])
# Compute the SS
SS[k, j] <- SS_func(y[R1], c1) + SS_func(y[R2],c2)
}
}
# The final results for the min SS
min_SS <- min(SS)
if(min_SS == Inf) {
return(NULL)
} # in case it cannot find any split such that both regions are > l
#example n=15, l = 5, but it cannot split it into two regions such that both regions have n >5, then it would just next all iterations and SS = inf
index <- which(SS == min_SS, arr.ind = TRUE)[1,] #in case of ties, index the first row
k <- index[1]
j <- index[2] #which column was used for the split-point
s <- X[k,j]# What value of X was used as the split-point
R1 <- which(X[,j] <= s)
R2 <- which(X[,j] > s)
result <- list(j=j, s = s,
R1 = R1, R2 = R2,  SS = min_SS)
return(result)
}
X_check <- as.matrix(Hitters[31: 50, c("Years", "Hits")])
y_check <- Hitters[31: 50, c("Salary")] # These are the names of the players we look at
rownames(Hitters)[31: 50]
tree_split(X_check, y_check, l = 5)
tree_split(X_check, y_check, l = 1)
# Chunk 6
first_train_split <-tree_split(X_train, y_train, l = 5)
first_train_split$j
first_train_split$s
first_train_split$SS
# Chunk 7
#' function to grow the tree nodes , for the first if statement in grow_tree
grow_node <- function(X, y, l, S_m, R_i ){
new_split <- tree_split(X[S_m[[1]], ], y[S_m[[1]]], l)
if(is.null(new_split)){
return(NULL) #as before, in case it cannot find any splits and
#the preallocated SS==Inf
}
new_results <- data.frame(
j = new_split$j,
s = new_split$s,
R1_i = R_i,
R2_i = R_i+1,
gamma = NA
)
return(list(new_results, new_split$R1, new_split$R2))
}
#' function to calculate the gamma value. The else statement in grow_tree
gamma_leaf <- function(y, S_m){
gamma <- mean(y[S_m[[1]]])
new_results <- data.frame(
j = NA,
s = NA,
R1_i = NA,
R2_i = NA,
gamma = gamma
)
return(new_results)
}
grow_tree <- function(X, y, l) {
assertions(X = X, y = y, l = l)
# Initialize the tree with the first split
init <- tree_split(X, y, l)
# Initialize S_m to store the set of observation indices
S_m <- list(init$R1, init$R2)
R_i <- 2
# Initialize results data frame
results <- data.frame(j = init$j, s = init$s,
R1_i = R_i, R2_i = R_i+1, gamma = NA)
# Main loop to grow the tree
while (length(S_m) > 0) {
# As long as not all parts of the tree have been handled,
# we will either split or compute gamma
if (length(S_m[[1]]) >= 2 * l) {
R_i <- R_i + 2
new_split <- grow_node(X=X, y=y, l=l,
S_m = S_m, R_i = R_i)
if(is.null(new_split)){ #this is added in case S_m[[1]]) >= 2 * l
# but the grow_node (tree split() cannot make any split of the observations
# such that both regions > l. Then we treat it as a leaf)
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
R_i <- R_i - 2
}
else{
results <- rbind(results,new_split[[1]])
S_m <- c(S_m, list(S_m[[1]][new_split[[2]]], S_m[[1]][new_split[[3]]]))
}
# Add R1 and R2 to S_m
#the long indexes is to make sure we index on the correct value for the whole
#data X, not the ones used for the current split only
S_m <- S_m[-1]
} else {
# Compute gamma for leaf node
leaf <- gamma_leaf(y=y, S_m = S_m)
results <- rbind(results, leaf)
S_m <- S_m[-1]
}
}
rownames(results) <- 1:nrow(results)
return(results)
}
# Chunk 8
debugonce(grow_tree)
tr <- grow_tree(as.matrix(X_check), y_check, l= 5)
tr
tr <- grow_tree(as.matrix(X_check), y_check, l= 5)
grow_tree(as.matrix(X_check), y_check, l= 1)
# Chunk 8
tr <- grow_tree(as.matrix(X_check), y_check, l= 5)
grow_tree(as.matrix(X_check), y_check, l= 1)
# Chunk 9
#' function to check whether a single observation is in a leaf or not given the
#' row of the tree to search in.
#' if not, then it returns the next region to search, else returns TRUE
check_leaf <- function(x, tree, n_row){
new_row <- n_row
gamma_na <- is.na(tree[n_row,]$gamma)
if (!gamma_na){
return( TRUE)
}
variable_to_split <- tree$j[n_row]
value_split <- tree$s[n_row]
if (x[variable_to_split] <= value_split){
new_row <- tree$R1_i[n_row]
}
else new_row <- tree$R2_i[n_row]
return(new_row)
}
predict_with_tree <- function(new_data, tree){
checkmate::assert_matrix(new_data)
predictions <- numeric(nrow(new_data))
for(i in 1:length(predictions)){
row=1
not_in_leaf <- TRUE
while(not_in_leaf){
iter_res <- check_leaf(x = new_data[i,], tree=tree, n_row=row)
if (iter_res ==TRUE){
not_in_leaf <- FALSE
predicted_value <- tree[row,]$gamma
}
else row <- iter_res
}
predictions[i] <- predicted_value
}
return(predictions)
}
# Chunk 10
X_new <- as.matrix(Hitters[51:52, c("Years", "Hits")])
y_new <- Hitters[51:52, c("Salary")]
predict_with_tree(X_new, tr)
rmse(x=c(75, 105, 33), y = c(102, 99, 43))
# Chunk 11
full_train_tree <- grow_tree(X=X_train, y = y_train, l = 5)
test_predictions <- predict_with_tree(X_test, tree= full_train_tree)
rmse(y_test, test_predictions) %>%
print()
# Chunk 13
library(randomForest)
data("Hitters")
Hitters <- Hitters[complete.cases(Hitters),]
dat_test <- Hitters[1:30, c("Salary", "Years", "Hits")]
dat_train <- Hitters[31:nrow(Hitters), c("Salary", "Years", "Hits")]
Hitters.rf <- randomForest(Salary ~ Years + Hits, data=dat_train, mtry=1)
# Chunk 14
Hitters.rf
# Chunk 15
randomForest(Salary ~ Years + Hits, data=dat_train, mtry=2)
# Chunk 16
RF_preds <- predict(Hitters.rf, newdata=dat_test)
rmse(x = dat_test$Salary, y = RF_preds)
# Chunk 17
library(xgboost)
X_test <- dat_test[1:30, c("Years", "Hits")]
y_test <- dat_test[1:30, c("Salary")]
X_train <- dat_train[31:nrow(Hitters), c("Years", "Hits")]
y_train <- dat_train[31:nrow(Hitters), c("Salary")]
X_train
nrow(dat_train)
nrow(Hitters)
xgb <- xgboost(as.matrix(X_train), as.matrix(y_train), nrounds = 200)
sample_func <- function(X, y) {
n <- length(y)
sampled_rows <- sample(1:n, size = n, replace = TRUE)
new_X <- X[sampled_rows, ]
new_y <- y[sampled_rows]
# Create a tibble with the same column names as X
new_X <- as_tibble(new_X) %>%
setNames(colnames(X))
# Combine X and y into a new tibble
new_df <- bind_cols(tibble(y = new_y), new_X)
return(new_df)
}
sample_func(X= X_train, y=y_train)
bootstrap_func <- function(X,y, B){
bootstrapped_datasets <- replicate(B, sample_func(X,y), simplify = FALSE)
#returns the bootstrapped sets in a list
return(bootstrapped_datasets)
}
#just a wrapper function to specify $y as y argument and
#all other variables as the X argument in matrix
grow_tree_on_boot <- function(dataset, l) {
grow_tree(X = as.matrix(dataset %>% select(-y)), y = dataset$y, l = l)
}
train_bagged_trees <- function(X, y, l, B){
bootstrapped_sets <- bootstrap_func( X=X, y=y, B=B)
bagged_trees <- lapply(bootstrapped_sets, grow_tree_on_boot, l = l)
return(bagged_trees)
}
